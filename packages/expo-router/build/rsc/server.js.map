{"version":3,"file":"server.js","sourceRoot":"","sources":["../../src/rsc/server.ts"],"names":[],"mappings":";;;;;;AAAA,iCAA8B;AA0C9B,SAAgB,aAAa,CAC3B,aAA4B,EAC5B,cAA+B,EAC/B,YAA2B;IAE3B,OAAO,EAAE,aAAa,EAAE,cAAc,EAAE,YAAY,EAAE,CAAC;AACzD,CAAC;AAND,sCAMC;AAaD,SAAgB,MAAM,CAAC,GAAW;IAChC,6DAA6D;IAC7D,OAAQ,UAAkB,CAAC,oBAAoB,CAAC,GAAG,CAAC,CAAC;AACvD,CAAC;AAHD,wBAGC;AAOD,wDAAgC;AAEhC,6DAA6D;AAC7D,oIAAoI;AACpI,SAAS,yBAAyB;IAChC,IAAI,CAAC,UAAU,CAAC,kBAAkB,EAAE;QAClC,UAAU,CAAC,kBAAkB,GAAG,IAAI,GAAG,EAAE,CAAC;KAC3C;IAED,IAAI,UAAU,CAAC,kBAAkB,CAAC,GAAG,CAAC,YAAE,CAAC,EAAE;QACzC,OAAO,CAAC,GAAG,CAAC,eAAe,EAAE,UAAU,CAAC,kBAAkB,CAAC,GAAG,CAAC,YAAE,CAAC,CAAC,CAAC;QACpE,OAAO,UAAU,CAAC,kBAAkB,CAAC,GAAG,CAAC,YAAE,CAAE,CAAC;KAC/C;IACD,MAAM,WAAW,GAAG,IAAA,aAAK,EAAC,GAAG,EAAE,CAAC,EAAsB,CAAC,CAAC;IACxD,UAAU,CAAC,kBAAkB,CAAC,GAAG,CAAC,YAAE,EAAE,WAAW,CAAC,CAAC;IACnD,OAAO,WAAW,CAAC;AACrB,CAAC;AAED,MAAM,sBAAsB,GAAG,yBAAyB,EAAE,CAAC;AAE3D;;GAEG;AACI,MAAM,gBAAgB,GAAG,CAAC,aAA4B,EAAE,EAAE;IAC/D,MAAM,MAAM,GAAG,sBAAsB,EAAE,CAAC;IACxC,MAAM,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC;AAC5B,CAAC,CAAC;AAHW,QAAA,gBAAgB,oBAG3B;AAEF,SAAgB,QAAQ,CAAC,KAAa,EAAE,YAA8B;IACpE,MAAM,MAAM,GAAG,sBAAsB,EAAE,CAAC;IACxC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE;QACd,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;KAClD;IACD,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;AAC1C,CAAC;AAND,4BAMC;AAED,SAAgB,UAAU;IAGxB,MAAM,MAAM,GAAG,sBAAsB,EAAE,CAAC;IACxC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE;QACd,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;KAClD;IACD,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC,OAAqB,CAAC;AACzC,CAAC;AARD,gCAQC","sourcesContent":["import { cache } from 'react';\n\nimport type { ReactNode } from 'react';\n\nimport type { PathSpec } from './path';\n\ntype Config = any;\n\ntype Elements = Record<string, ReactNode>;\n\nexport type RenderEntries = (\n  input: string,\n  searchParams: URLSearchParams\n) => Promise<Elements | null>;\n\nexport type GetBuildConfig = (\n  unstable_collectClientModules: (input: string) => Promise<string[]>\n) => Promise<\n  Iterable<{\n    pathname: string | PathSpec; // TODO drop support for string?\n    isStatic?: boolean;\n    entries?: Iterable<{\n      input: string;\n      skipPrefetch?: boolean;\n      isStatic?: boolean;\n    }>;\n    customCode?: string; // optional code to inject TODO hope to remove this\n    context?: Record<string, unknown>;\n  }>\n>;\n\nexport type GetSsrConfig = (\n  pathname: string,\n  options: {\n    searchParams: URLSearchParams;\n  }\n) => Promise<{\n  input: string;\n  searchParams?: URLSearchParams;\n  body: ReactNode;\n} | null>;\n\nexport function defineEntries(\n  renderEntries: RenderEntries,\n  getBuildConfig?: GetBuildConfig,\n  getSsrConfig?: GetSsrConfig\n) {\n  return { renderEntries, getBuildConfig, getSsrConfig };\n}\n\nexport type EntriesDev = {\n  default: ReturnType<typeof defineEntries>;\n};\n\nexport type EntriesPrd = EntriesDev & {\n  loadConfig: () => Promise<Config>;\n  loadModule: (id: string) => Promise<unknown>;\n  dynamicHtmlPaths: [pathSpec: PathSpec, htmlHead: string][];\n  publicIndexHtml: string;\n};\n\nexport function getEnv(key: string): string | undefined {\n  // HACK we may want to use a server-side context or something\n  return (globalThis as any).__WAKU_PRIVATE_ENV__[key];\n}\n\ntype RenderContext<RscContext extends Record<string, unknown> = Record<string, unknown>> = {\n  rerender: (input: string, searchParams?: URLSearchParams) => void;\n  context: RscContext;\n};\n\nimport OS from 'expo-router/os';\n\n// TODO(EvanBacon): This can leak between platforms and runs.\n// We need to share this module between the server action module and the renderer module, per platform, and invalidate on refreshes.\nfunction getGlobalCacheForPlatform() {\n  if (!globalThis.__EXPO_RSC_CACHE__) {\n    globalThis.__EXPO_RSC_CACHE__ = new Map();\n  }\n\n  if (globalThis.__EXPO_RSC_CACHE__.has(OS)) {\n    console.log('[RSC]: REUSE:', globalThis.__EXPO_RSC_CACHE__.get(OS));\n    return globalThis.__EXPO_RSC_CACHE__.get(OS)!;\n  }\n  const serverCache = cache(() => [] as [RenderContext?]);\n  globalThis.__EXPO_RSC_CACHE__.set(OS, serverCache);\n  return serverCache;\n}\n\nconst getRenderContextHolder = getGlobalCacheForPlatform();\n\n/**\n * This is an internal function and not for public use.\n */\nexport const setRenderContext = (renderContext: RenderContext) => {\n  const holder = getRenderContextHolder();\n  holder[0] = renderContext;\n};\n\nexport function rerender(input: string, searchParams?: URLSearchParams) {\n  const holder = getRenderContextHolder();\n  if (!holder[0]) {\n    throw new Error('[Bug] No render context found');\n  }\n  holder[0].rerender(input, searchParams);\n}\n\nexport function getContext<\n  RscContext extends Record<string, unknown> = Record<string, unknown>,\n>(): RscContext {\n  const holder = getRenderContextHolder();\n  if (!holder[0]) {\n    throw new Error('[Bug] No render context found');\n  }\n  return holder[0].context as RscContext;\n}\n"]}